// swift-interface-format-version: 1.0
// swift-compiler-version: Apple Swift version 5.9.2 (swiftlang-5.9.2.2.56 clang-1500.1.0.2.5)
// swift-module-flags: -target x86_64-apple-ios12.0-simulator -enable-objc-interop -enable-library-evolution -swift-version 5 -enforce-exclusivity=checked -O -module-name Kindly
// swift-module-flags-ignorable: -enable-bare-slash-regex
import Combine
import DeveloperToolsSupport
import Foundation
@_exported import Kindly
import LocalAuthentication
import Network
import OSLog
import PhotosUI
import SafariServices
import Security
import SnapKit
import Starscream
import Swift
import SwiftUI
import SwiftyGif
import SwiftyJSON
import UIKit.UIColor
import UIKit.UIDevice
import UIKit.UIImage
import UIKit
import UniformTypeIdentifiers
import UserNotifications
import WebKit
import _Concurrency
import _StringProcessing
import _SwiftConcurrencyShims
extension Dispatch.DispatchQueue {
  public static func background(background: @escaping (() -> Swift.Void), delay: Dispatch.DispatchTimeInterval? = nil, completionOnMain: (() -> Swift.Void)? = nil, completionDelay: Swift.Double? = nil)
  public static func main(_ code: @escaping (() -> Swift.Void), delay: Dispatch.DispatchTimeInterval? = nil)
}
public struct ExternalChatMessage : Swift.Hashable, Swift.Identifiable, Swift.Comparable {
  public let id: Swift.String
  public static func < (lhs: Kindly.ExternalChatMessage, rhs: Kindly.ExternalChatMessage) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public static func == (a: Kindly.ExternalChatMessage, b: Kindly.ExternalChatMessage) -> Swift.Bool
  public typealias ID = Swift.String
  public var hashValue: Swift.Int {
    get
  }
}
public enum ExternalExchangeType : Swift.String, Swift.Encodable {
  case dialogue
  case fallback
  case greeting
  case systemDialogue
  case userSays
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public enum ExternalChatMessageSender : Swift.String, Swift.Encodable {
  case agent
  case bot
  case system
  case unknown
  case user
  public init?(rawValue: Swift.String)
  public typealias RawValue = Swift.String
  public var rawValue: Swift.String {
    get
  }
}
public struct UserMessage : Swift.Encodable {
  public let message: Swift.String
  public var newContext: [Swift.String : Swift.String]?
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct ConnectRequestModel : Swift.Encodable {
  public var context: [Swift.String : Swift.String]?
  public func encode(to encoder: any Swift.Encoder) throws
}
public struct Bot {
  public let name: Swift.String
  public let avatarURL: Foundation.URL?
}
@propertyWrapper public class Announced<Value> {
  public var wrappedValue: Value {
    get
    set
  }
  public init(wrappedValue: Value)
  public var projectedValue: Kindly.Announced<Value> {
    get
  }
  @objc deinit
}
public typealias LanguageCode = Swift.String
public struct Language {
  public let code: Kindly.LanguageCode
  public let name: Swift.String
}
extension Swift.Set {
  public var array: [Element] {
    get
  }
}
public struct KindlySDKConfig {
  public var getAuthToken: Kindly.AuthTokenCallback? {
    get
    set
  }
  public init(botKey: Swift.String, environment: Kindly.Config.Environment = .prod, authTokenCallback: Kindly.AuthTokenCallback? = nil)
}
@objc @_inheritsConvenienceInitializers @objcMembers public class Config : ObjectiveC.NSObject {
  public static var environment: Kindly.Config.Environment
  @objc override dynamic public init()
  @objc deinit
}
extension Kindly.Config {
  public struct Environment : Swift.RawRepresentable, Swift.Equatable {
    public var rawValue: Swift.String
    public init(rawValue: Swift.String)
    public static func == (lhs: Kindly.Config.Environment, rhs: Kindly.Config.Environment) -> Swift.Bool
    public static let dev: Kindly.Config.Environment
    public static let prod: Kindly.Config.Environment
    public typealias RawValue = Swift.String
  }
  public static func setEnvironment(_ env: Kindly.Config.Environment) -> Kindly.Config.Environment
  @objc public static var isDevelopment: Swift.Bool {
    @objc get
  }
  @objc public static var isProduction: Swift.Bool {
    @objc get
  }
  @objc public static var environmentDisplayName: Swift.String {
    @objc get
  }
  @objc public static var environmentConfigKeyName: Swift.String {
    @objc get
  }
}
extension Kindly.Config {
  @objc public static var API_HOST: Swift.String {
    @objc get
  }
  @objc public static var API_PORT: Swift.Int {
    @objc get
  }
  @objc public static var API_ENDPOINT: Swift.String {
    @objc get
  }
  @objc public static var LOG_PRINTS: Swift.Bool {
    @objc get
  }
  @objc public static var VERSION: Swift.String {
    @objc get
  }
  @objc public static var BUILD: Swift.String {
    @objc get
  }
}
public struct ExternalChatButton {
}
public enum ChatConnectionState {
  case none
  case disconnected
  case connecting
  case connected
  case conversationEnded
  case failed
  public static func == (a: Kindly.ChatConnectionState, b: Kindly.ChatConnectionState) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
public protocol KindlyChatClientDelegate : ObjectiveC.NSObject {
  func didPressButton(chatButton: Kindly.ExternalChatButton, chatLog: [Kindly.ExternalChatMessage])
}
public typealias KindlySDK = Kindly.KindlyChatClient
final public class KindlyChatClient {
  public static var shared: Kindly.KindlyChatClient!
  public static var config: Kindly.KindlySDKConfig {
    get
    set
  }
  public static var connectionState: Kindly.ChatConnectionState {
    get
  }
  public static var delegate: (any Kindly.KindlyChatClientDelegate)! {
    get
    set
  }
  public static var notificationDelegate: Kindly.NotificationDelegate {
    get
  }
  public init(config: Kindly.KindlySDKConfig)
  @objc deinit
}
extension Kindly.KindlyChatClient {
  final public class func start(botKey: Swift.String, authTokenCallback: Kindly.AuthTokenCallback? = nil)
  final public class func setNewContext(_ context: [Swift.String : Swift.String])
  final public func setNewContext(_ context: [Swift.String : Swift.String])
  final public class func clearNewContext()
  final public func clearNewContext()
  final public class func setAPNSDeviceToken(_ deviceToken: Foundation.Data)
  final public class func setAPNSDeviceToken(_ deviceToken: Swift.String)
  @discardableResult
  final public class func saveAuthToken(_ token: Swift.String) -> Swift.Bool
  @discardableResult
  final public func saveAuthToken(_ token: Swift.String) -> Swift.Bool
  final public class func displayChat(languageCode: Swift.String? = nil)
  final public func displayChat(languageCode: Swift.String? = nil)
  final public class func closeChat()
  final public func closeChat()
  final public class func endChat() -> Kindly.Promise<Swift.Void>
  final public func endChat() -> Kindly.Promise<Swift.Void>
  final public class func notificationReceived(_ userInfo: [Swift.AnyHashable : Any])
  final public class func notificationReceived(_ notification: UserNotifications.UNNotification)
  final public class func notificationResponseReceived(_ response: UserNotifications.UNNotificationResponse)
}
@objc @_inheritsConvenienceInitializers public class NotificationDelegate : ObjectiveC.NSObject, UserNotifications.UNUserNotificationCenterDelegate {
  @objc public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, willPresent notification: UserNotifications.UNNotification, withCompletionHandler completionHandler: @escaping (UserNotifications.UNNotificationPresentationOptions) -> Swift.Void)
  @objc public func userNotificationCenter(_ center: UserNotifications.UNUserNotificationCenter, didReceive response: UserNotifications.UNNotificationResponse, withCompletionHandler completionHandler: @escaping () -> Swift.Void)
  @objc override dynamic public init()
  @objc deinit
}
extension Dispatch.DispatchQueue {
  public static var _promises: Dispatch.DispatchQueue?
  public static var promises: Dispatch.DispatchQueue {
    get
    set
  }
}
public class Promise<T> {
  public typealias onFulfilled = (T) throws -> Swift.Void
  public typealias onRejected = (any Swift.Error) -> Swift.Void
  public init()
  public init(_ promise: Kindly.Promise<T>)
  public static func pending() -> Kindly.Promise<T>
  public func setPromise(_ promise: Kindly.Promise<T>)
  @objc deinit
}
extension Kindly.Promise {
  public func fulfill(_ value: T)
  public func reject(_ error: any Swift.Error)
  @discardableResult
  public func then(on queue: Dispatch.DispatchQueue = .promises, _ onFulfilled: @escaping Kindly.Promise<T>.onFulfilled) -> Kindly.Promise<T>
  @discardableResult
  public func `catch`(on queue: Dispatch.DispatchQueue = .promises, _ onRejected: @escaping Kindly.Promise<T>.onRejected) -> Kindly.Promise<T>
  @discardableResult
  public func always(on queue: Dispatch.DispatchQueue = .promises, _ block: @escaping () -> Swift.Void) -> Kindly.Promise<T>
}
public enum KindlySDKError : Swift.Error {
  case configNotSet
  case connectionIsInProgress
  case general
  case httpError(statusCode: Swift.Int)
  case invalidURL
  case noInternetConnection
  case tokenInvalid
  case tokenMissing
  case invalidData
  case generic(description: Swift.String)
  case invalidJWTPartCount(Swift.String, Swift.Int)
  case invalidBase64URL(Swift.String)
  case invalidJSON(Swift.String)
}
public func print(_ items: [Swift.String], filename: Swift.String = #file, function: Swift.String = #function, line: Swift.Int = #line, separator: Swift.String = " ", terminator: Swift.String = "\n", sameLine: Swift.Bool? = nil)
@available(iOS 14, *)
public func print(_ items: os.OSLogMessage..., logger: os.Logger? = nil, level: os.OSLogType? = nil, separator: Swift.String = " ", terminator: Swift.String = "\n")
public func print(_ items: [Swift.String], separator: Swift.String = " ", terminator: Swift.String = "\n")
public protocol KeychainServiceProtocol {
  static var id: Swift.String { get }
  static var keychainService: Kindly.KeychainService { get }
  static func save(value: Swift.String) -> Swift.Bool
  static func read() -> Swift.String?
  static func delete()
}
extension Kindly.KeychainServiceProtocol {
  public static var keychainService: Kindly.KeychainService {
    get
  }
  public static func save(value: Swift.String) -> Swift.Bool
  public static func read() -> Swift.String?
  public static func delete()
  public static func clear()
}
@_hasMissingDesignatedInitializers public class KeychainService {
  public func save(text: Swift.String) -> Swift.Bool
  public func read() -> Swift.String?
  @discardableResult
  public func delete() -> Swift.Bool
  @objc deinit
}
public enum DateFormatEnum {
  case MMMMddyyyy
  case ddMMMMyyyyhhmm
  case iso8601
  public static func == (a: Kindly.DateFormatEnum, b: Kindly.DateFormatEnum) -> Swift.Bool
  public func hash(into hasher: inout Swift.Hasher)
  public var hashValue: Swift.Int {
    get
  }
}
extension Swift.Array {
  public var isNotEmpty: Swift.Bool {
    get
  }
  public func safeToUseIndex(_ index: Swift.Int) -> Swift.Bool
}
public typealias AuthTokenCallback = (_ chatId: Swift.String, _ promise: Kindly.Promise<Swift.String>) -> ()
@objc @_inheritsConvenienceInitializers @_hasMissingDesignatedInitializers @_Concurrency.MainActor(unsafe) final public class KindlyChatNavigationController : UIKit.UINavigationController {
  @_Concurrency.MainActor(unsafe) public init(languageCode: Swift.String?)
  @_Concurrency.MainActor(unsafe) @objc override final public func viewDidLoad()
  @_Concurrency.MainActor(unsafe) @objc override final public func viewWillAppear(_ animated: Swift.Bool)
  @objc deinit
}
extension Kindly.ExternalExchangeType : Swift.Equatable {}
extension Kindly.ExternalExchangeType : Swift.Hashable {}
extension Kindly.ExternalExchangeType : Swift.RawRepresentable {}
extension Kindly.ExternalChatMessageSender : Swift.Equatable {}
extension Kindly.ExternalChatMessageSender : Swift.Hashable {}
extension Kindly.ExternalChatMessageSender : Swift.RawRepresentable {}
extension Kindly.ChatConnectionState : Swift.Equatable {}
extension Kindly.ChatConnectionState : Swift.Hashable {}
extension Kindly.DateFormatEnum : Swift.Equatable {}
extension Kindly.DateFormatEnum : Swift.Hashable {}
